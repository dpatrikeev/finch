---
alwaysApply: true
---

Помни: чем меньше и проще код, тем меньше багов. 

# Архитектурные правила для Finch v2.0 - Remote Functions

## Обзор изменений

С переходом на **Remote Functions** в SvelteKit мы кардинально упрощаем архитектуру проекта:

- ❌ Убираем `api/` папки в фичах
- ❌ Убираем большинство `+page.server.ts` файлов  
- ❌ Убираем stores для серверного состояния
- ✅ Добавляем `data.remote.ts` для всех серверных функций
- ✅ Используем `await` expressions в компонентах
- ✅ Получаем автоматическую реактивность данных

## Структура проекта

### Обязательная структура фичи (v2.0)

```text
src/lib/features/[feature-name]/
├── data.remote.ts              # ✨ ВСЕ серверные функции (queries, commands, forms)
├── components/
│   ├── index.ts                # Экспорт компонентов
│   └── # Презентационные компоненты
├── types/
│   └── [feature].types.ts      # TypeScript типы
├── utils/
│   └── [feature].utils.ts      # Утилиты (чистые функции)
├── tests/
│   ├── [feature].utils.test.ts # Тесты утилит
│   └── [feature].remote.test.ts # ✨ Тесты remote functions
├── [Feature].svelte            # Главный компонент с прямым доступом к данным
├── index.ts                    # Публичный API (включая data.remote)
└── README.md                   # Документация
```

### Что убрано из структуры:
- ❌ `api/` папка полностью
- ❌ `stores/` папка (заменена на reactive queries)

## Правила архитектуры

### 1. data.remote.ts - единственный способ работы с сервером

**Структура файла:**

```typescript
import { query, command, form } from '$app/server';
import { getRequestEvent } from '$app/server';
import * as v from 'valibot'; // для валидации

// ✅ Queries - для чтения данных
export const getData = query(async (): Promise<DataType[]> => {
  const { locals } = getRequestEvent();
  // логика получения данных
  return data;
});

export const getDataById = query(
  v.string(), // валидация аргумента
  async (id: string): Promise<DataType | null> => {
    const { locals } = getRequestEvent();
    // логика получения данных по ID
    return data;
  }
);

// ✅ Commands - для мутаций без форм
export const updateData = command(
  v.object({
    id: v.pipe(v.string(), v.minLength(1, 'ID обязателен')),
    title: v.pipe(v.string(), v.minLength(1, 'Название обязательно'), v.maxLength(100, 'Слишком длинное название'))
  }),
  async ({ id, title }) => {
    const { locals } = getRequestEvent();
    // логика обновления
    
    // Обновляем связанные queries
    await getData().refresh();
    
    return { success: true, message: 'Данные обновлены' };
  }
);

// ✅ Forms - для HTML форм (если нужны)
export const createData = form(async (data) => {
  const { locals } = getRequestEvent();
  const title = data.get('title');
  // логика создания
  return { success: true };
});
```

### 2. Главный компонент с прямым доступом к данным

```svelte
<script lang="ts">
  import { getData, updateData } from './data.remote';
  import { Component1, Component2 } from './components';
  
  // ✅ Прямая загрузка данных в компоненте
  const data = $derived(await getData());
  
  // ✅ Функции для мутаций
  async function handleUpdate(newData) {
    try {
      await updateData(newData);
      // getData автоматически обновится благодаря refresh()
    } catch (error) {
      console.error('Ошибка обновления:', error);
    }
  }
</script>

{#each data as item}
  <Component1 {item} onUpdate={handleUpdate} />
{/each}
```

### 3. Страницы как тонкая обертка

```svelte
<script lang="ts">
  import { Feature } from '$lib/features/feature-name';
</script>

<svelte:head>
  <title>Страница - Finch</title>
</svelte:head>

<!-- ✅ Обязательная обертка для await expressions -->
<svelte:boundary>
  <section class="mx-auto p-5 md:p-10">
    <h1>Заголовок</h1>
    <Feature />
  </section>
  
  {#snippet pending()}
    <div class="flex justify-center py-8">
      <div class="animate-spin rounded-full h-8 w-8 border-b-2 border-primary"></div>
    </div>
  {/snippet}
</svelte:boundary>
```

### 4. Валидация с valibot

```typescript
import * as v from 'valibot';

// ✅ Простые типы
export const getUser = query(
  v.string(), 
  async (userId: string) => { /* ... */ }
);

// ✅ Сложные объекты
export const createPost = command(
  v.object({
    title: v.pipe(v.string(), v.minLength(1), v.maxLength(100)),
    content: v.string(),
    tags: v.array(v.string()),
    publishedAt: v.optional(v.date())
  }),
  async (data) => { /* ... */ }
);

// ❌ Не используйте 'unchecked' без веской причины
export const unsafeFunction = command(
  'unchecked', // Только в крайних случаях!
  async (data) => { /* ... */ }
);
```

### 5. Обновление данных

```typescript
// ✅ В remote function - автоматическое обновление
export const createItem = command(
  v.object({ title: v.string() }),
  async (data) => {
    const result = await db.create(data);
    
    // Обновляем связанные queries
    await getItems().refresh();
    
    return result;
  }
);

// ✅ В компоненте - ручное обновление
async function handleCreate(data) {
  await createItem(data);
  // getItems() автоматически обновится
}

// ✅ Оптимистичные обновления
async function optimisticUpdate(newItem) {
  try {
    await createItem(newItem);
  } catch (error) {
    // При ошибке показываем уведомление
    toast.error('Ошибка создания элемента');
  }
}
```

### 6. Обработка ошибок

```typescript
// ✅ В remote functions
export const riskyOperation = command(
  v.string(),
  async (id: string) => {
    try {
      const result = await someRiskyOperation(id);
      return { success: true, data: result };
    } catch (error) {
      // Логируем на сервере
      console.error('Ошибка операции:', error);
      // Бросаем понятную ошибку для клиента
      throw new Error('Не удалось выполнить операцию');
    }
  }
);

// ✅ В компонентах
async function handleRiskyAction() {
  try {
    await riskyOperation(itemId);
    toast.success('Операция выполнена успешно');
  } catch (error) {
    const message = error instanceof Error ? error.message : 'Неизвестная ошибка';
    toast.error(message);
  }
}
```

## Миграционный план

### Этап 1: Подготовка (✅ Готово)
- [x] `remoteFunctions: true` в svelte.config.js
- [x] `async: true` в compilerOptions  
- [x] Установить valibot: `bun add valibot`

### Этап 2: Миграция фич (одна за раз)
1. ✅ **Students** - мигрирована
2. [ ] **Homework** - следующая
3. [ ] **Exercises** 
4. [ ] **Quiz**
5. [ ] **Notation**

### План миграции одной фичи:
1. Создать `data.remote.ts`
2. Перенести логику из `api/queries.ts` → queries в remote
3. Перенести логику из `api/actions.ts` → commands в remote  
4. Обновить главный компонент фичи
5. Упростить страницы (убрать `+page.server.ts`)
6. Удалить папку `api/`
7. Обновить `index.ts` фичи
8. Обновить тесты

### Этап 3: Очистка
- Удалить неиспользуемые `+page.server.ts`
- Обновить документацию фич
- Обновить README проекта

## Примеры кода

### До (старая архитектура):
```text
Цепочка: +page.server.ts → api/queries.ts → +page.svelte → Feature.svelte
```

```typescript
// src/routes/students/+page.server.ts
export const load = async ({ locals }) => {
  const students = await loadTeacherStudents(locals);
  return { students };
};

// src/routes/students/+page.svelte  
let { data } = $props();
<Students students={data.students} />

// src/lib/features/students/Students.svelte
const { students } = $props();
```

### После (Remote Functions):
```text
Цепочка: Feature.svelte → data.remote.ts
```

```typescript
// src/lib/features/students/data.remote.ts
export const getTeacherStudents = query(async () => {
  const { locals } = getRequestEvent();
  // логика загрузки
  return students;
});

// src/routes/students/+page.svelte (упрощенная)
<svelte:boundary>
  <Students />
  {#snippet pending()}<div>Загрузка...</div>{/snippet}
</svelte:boundary>

// src/lib/features/students/Students.svelte
const students = $derived(await getTeacherStudents());
```

## Преимущества новой архитектуры

### Количественные:
- **-40% файлов** в каждой фиче
- **-60% строк кода** в маршрутах  
- **-100% дублирования** типов между сервером и клиентом

### Качественные:
- **Прямой доступ к данным** из компонентов
- **Автоматическая реактивность** без stores
- **Типобезопасность из коробки**
- **Меньше бойлерплейта**
- **Проще тестирование**

## Запрещенные паттерны

**❌ НЕ ДЕЛАТЬ:**

1. **Смешивание подходов:**
```typescript
// ПЛОХО - не смешивай load functions и remote functions
export const load = async ({ locals }) => {
  const data = await someRemoteFunction(); // НЕТ!
};
```

2. **Состояние в remote functions:**
```typescript
// ПЛОХО - remote functions stateless
let cache = new Map();
export const getData = query(async () => {
  if (cache.has('key')) return cache.get('key'); // НЕТ!
});
```

3. **Игнорирование валидации:**
```typescript
// ПЛОХО - всегда валидируй
export const updateUser = command('unchecked', async (data) => {
  // небезопасно!
});
```

4. **Забывание про svelte:boundary:**
```svelte
<!-- ПЛОХО - await без boundary -->
<div>
  {#each await getData() as item}
    <div>{item.name}</div>
  {/each}
</div>
```

5. **Не обновлять связанные queries:**
```typescript
// ПЛОХО - данные не обновятся
export const createItem = command(v.object({}), async (data) => {
  await db.create(data);
  // Забыли: await getItems().refresh();
  return { success: true };
});
```

6. **Избыточные утилиты и тесты:**
```typescript
// ❌ ПЛОХО - тривиальные утилиты
export function formatName(first: string, last: string) {
  return `${first} ${last}`; // Лучше инлайн в компоненте
}

// ❌ ПЛОХО - хрупкие тесты CSS классов
expect(getAccuracyColor(85)).toBe('bg-green-500'); // Сломается при смене дизайна

// ✅ ХОРОШО - критичная бизнес-логика
export function calculateStudentsStats(students, totalExercises) {
  // Сложные вычисления - нужны тесты
}
```

## Правила для утилит и тестов

### ✅ СОЗДАВАТЬ утилиты для:

1. **Критичной бизнес-логики:**
   - Сложные вычисления (статистика, проценты)
   - Алгоритмы фильтрации и сортировки
   - Валидация данных

2. **Переиспользуемой логики:**
   - Функции, используемые в 3+ местах
   - Сложные трансформации данных

### ❌ НЕ СОЗДАВАТЬ утилиты для:

1. **Простого форматирования:**
2. **CSS классов и стилей:**
3. **Одноразовой логики:**
   - Функции, используемые только в одном месте
   - Тривиальные проверки и преобразования

### ✅ ПИСАТЬ тесты для:

1. **Критичной бизнес-логики:**
   ```typescript
   // ✅ Важные вычисления
   describe('calculateStudentsStats', () => {
     it('should calculate completion rate correctly', () => {
       expect(stats.completionRate).toBe(75);
     });
   });
   ```

2. **Пользовательских функций:**
   ```typescript
   // ✅ Поиск и сортировка влияют на UX
   describe('filterStudents', () => {
     it('should find students by name', () => {
       expect(filtered).toHaveLength(2);
     });
   });
   ```

3. **Граничных случаев:**
   ```typescript
   // ✅ Важно протестировать edge cases
   it('should handle empty input gracefully', () => {
     expect(calculateStats([])).toEqual({ total: 0, active: 0 });
   });
   ```

### ❌ НЕ ПИСАТЬ тесты для:

1. **CSS классов:**
   ```typescript
   // ❌ Хрупкие, не критичные
   expect(getAccuracyColor(85)).toBe('bg-green-500');
   ```

2. **Простого форматирования:**
   ```typescript
   // ❌ Тривиально
   expect(formatInitials('John', 'Doe')).toBe('JD');
   ```

3. **Неиспользуемых функций:**
   ```typescript
   // ❌ Мертвый код
   expect(isValidStudentInfo(student)).toBe(true);
   ```

### 🎯 Ключевые принципы:

#### 1. "Простое - прямо в разметку"

**Правило:** Если логика помещается в одну строку - пиши прямо в JSX/разметке

```svelte
<!-- ❌ Избыточно -->
<script>
  const fullName = (first, last) => [first, last].filter(Boolean).join(' ');
</script>
<h1>{fullName(student.firstName, student.lastName)}</h1>

<!-- ✅ Проще и понятнее -->
<h1>{[student.firstName, student.lastName].filter(Boolean).join(' ')}</h1>

<!-- ✅ Короткие условия -->
<div class="{accuracy > 80 ? 'text-green-600' : 'text-red-600'}">

<!-- ✅ Простые вычисления -->
<span>{Math.round(progress * 100)}%</span>
```

**Когда выносить в функцию:**
- Логика сложнее 1 строки
- Повторяется 3+ раз в компоненте
- Критичная бизнес-логика

#### 2. "Тестируй ценность, не покрытие"

**Хорошие тесты:**
- Защищают от регрессии в критичной логике
- Документируют ожидаемое поведение
- Быстро выполняются и стабильны
- Легко понять и поддерживать

**Плохие тесты:**
- Тестируют тривиальную логику
- Ломаются при изменении дизайна
- Дублируют функциональность
- Тестируют неиспользуемый код

## Тестирование

### Тестирование remote functions:

```typescript
// src/lib/features/students/tests/students.remote.test.ts
import { describe, it, expect, vi } from 'vitest';
import { getTeacherStudents } from '../data.remote';

// Мокаем getRequestEvent
vi.mock('$app/server', () => ({
  getRequestEvent: () => ({
    locals: {
      auth: () => ({ userId: 'teacher-123' })
    }
  })
}));

describe('Students Remote Functions', () => {
  it('should load teacher students', async () => {
    const students = await getTeacherStudents();
    expect(students).toBeDefined();
    expect(Array.isArray(students)).toBe(true);
  });
});
```

### Тестирование компонентов:

```typescript
// Компоненты с remote functions требуют особого подхода к тестированию
// Используйте моки для remote functions
vi.mock('../data.remote', () => ({
  getTeacherStudents: vi.fn(() => Promise.resolve([]))
}));
```

### 📊 Результат упрощения тестов:

**До (students feature):**
- 8 групп тестов (270 строк)
- Тестировались CSS классы, форматирование, неиспользуемые функции
- 50% тестов были бесполезными

**После:**
- 4 группы тестов (~130 строк)
- Только критичная бизнес-логика и пользовательские функции
- 100% полезных тестов

**Выгода:**
- ⚡ **-50% времени** на выполнение тестов
- 🔧 **-50% усилий** на поддержку тестов
- 📈 **+100% качества** покрытия
- 🎯 **Фокус на важном**, а не на покрытии

## Заключение

Переход на Remote Functions значительно упрощает архитектуру проекта:

- **Меньше файлов и папок**
- **Прямой доступ к данным**  
- **Автоматическая реактивность**
- **Лучшая типобезопасность**
- **Проще разработка и поддержка**

Следуйте этим правилам при создании новых фич и миграции существующих.
